# 実装順序計画: エンティティ依存グラフに基づく実装アプローチ

## 1. エンティティ依存関係グラフ

以下は主要エンティティの依存関係を示したグラフです。実線の矢印はデータモデルの参照関係を、点線の矢印はビジネスロジック上の依存関係を示しています。

```
Organization <---- Subscription <---- Invoice
      ^
      |
      v
     User <------- SajuProfile
      ^
      |           /|\
      |            |
      v            |
     Team ------> TeamGoal
      |             ^
      |             |
      v             |
Compatibility       |
      |             |
      v             |
 DailyFortune <---・・
      ^
      |
      |
UserGoal・・・・・・・・・
      ^
      |
DayPillar
      |
      v
 ChatHistory
```

このグラフの重要なポイント：
- DailyFortuneは、単純なデータモデル参照関係だけでなく、実際の運勢生成ロジックにおいてTeamGoalとUserGoalのデータに依存しています（点線で表示）
- DailyFortuneの生成には、DayPillarの情報が必須です
- ChatHistoryは、DailyFortune、UserGoal、SajuProfileなどのデータをコンテキストとして使用します

## 2. 実装フェーズと優先順位

依存関係に基づく正確な実装順序は以下の通りです。

### フェーズ1: 基本エンティティとユーザー認証（既に実装済み）

1. **Organization モデル**
   - モデル、コントローラー、サービス 
   - 関連フロントエンドコンポーネント: SuperAdmin管理サイトの組織管理ページ

2. **User モデル & 認証システム**
   - モデル、コントローラー、サービス 
   - Firebase Auth 連携
   - 関連フロントエンドコンポーネント: ログインページ、ユーザー登録、プロフィール設定の基本部分

3. **Team モデル**
   - モデル、コントローラー、サービス
   - 関連フロントエンドコンポーネント: チームページの基本部分、チーム管理UI（Admin用）

### フェーズ2: 四柱推命プロフィールと日柱データ

4. **SajuProfile モデル**
   - モデル、コントローラー、サービス
   - SajuEngine連携によるプロフィール生成
   - 関連フロントエンドコンポーネント: プロフィール設定画面の四柱推命情報表示部分

5. **DayPillar モデル**
   - モデル、コントローラー、サービス
   - 毎日更新バッチジョブ
   - SajuEngine連携による日柱計算
   - 関連フロントエンドコンポーネント: なし（バックエンド処理のみ）

### フェーズ3: チームと目標機能の実装

6. **TeamGoal モデル**
   - モデル、コントローラー、サービス
   - 関連フロントエンドコンポーネント: チーム管理画面のチーム目標設定部分（Admin用）

7. **UserGoal モデル**
   - モデル、コントローラー、サービス
   - 関連フロントエンドコンポーネント: プロフィール設定画面の目標設定部分

8. **チーム管理フロントエンド**
   - チームメンバー管理
   - チーム目標管理
   - 権限設定UI

### フェーズ4: 運勢と相性機能

9. **DailyFortune モデル**
   - モデル、コントローラー、サービス
   - 運勢生成ロジック（SajuEngine、UserGoal、TeamGoalデータを統合）
   - 毎日3時の自動更新バッチジョブ
   - 関連フロントエンドコンポーネント: デイリー運勢表示ページ

10. **Compatibility モデル**
    - モデル、コントローラー、サービス
    - 相性計算ロジック
    - 関連フロントエンドコンポーネント: チームページの相性表示部分

### フェーズ5: AIチャット機能

11. **ChatHistory モデル**
    - モデル、コントローラー、サービス
    - Claude AI API連携
    - 複数コンテキスト対応（個人運勢/チームメンバー相性/チーム目標）
    - 関連フロントエンドコンポーネント: 統合AIチャットページ

### フェーズ6: サブスクリプションと管理機能

12. **Subscription & PricePlan モデル**
    - モデル、コントローラー、サービス
    - 決済サービス連携
    - 関連フロントエンドコンポーネント: サブスクリプション管理ページ

13. **Invoice モデル**
    - モデル、コントローラー、サービス
    - 請求書生成ロジック
    - 関連フロントエンドコンポーネント: 請求情報表示ページ

14. **UsageStatistics モデル**
    - モデル、コントローラー、サービス
    - 統計データ収集ロジック
    - 関連フロントエンドコンポーネント: 管理者ダッシュボード統計表示部分

15. **SystemSetting モデル**
    - モデル、コントローラー、サービス
    - 関連フロントエンドコンポーネント: システム設定ページ（SuperAdmin用）

16. **Alert & NotificationLog モデル**
    - モデル、コントローラー、サービス
    - アラート検出ロジック
    - 関連フロントエンドコンポーネント: 経営者ダッシュボードのアラート表示部分

### フェーズ7: バッチ処理と監査ログ

17. **BatchJobLog & AuditLog モデル**
    - モデル、コントローラー、サービス
    - バッチ処理の実装とスケジューリング
    - 関連フロントエンドコンポーネント: システム管理ページのジョブ履歴表示部分（SuperAdmin用）

18. **DailyFortuneUpdateLog モデル**
    - モデル、コントローラー、サービス
    - 運勢更新プロセスの監視とログ記録
    - 関連フロントエンドコンポーネント: 運勢更新ログ表示ページ（SuperAdmin用）

## 3. フロントエンド実装順序

フロントエンドの実装は、バックエンドの実装順序に合わせて以下の順序で進めるべきです：

1. **ログインページ**
   - [モックアップ](../mockups/login-page.html)
   - バックエンド連携: User認証API
   - 優先度: 最高

2. **プロフィール設定ページ - 四柱推命情報**
   - [モックアップ](../mockups/profile-settings.html)
   - バックエンド連携: SajuProfile API
   - 優先度: 高

3. **プロフィール設定ページ - 目標設定**
   - [モックアップ](../mockups/profile-settings.html)
   - バックエンド連携: UserGoal API
   - 優先度: 高

4. **チームページ - チーム管理**
   - [モックアップ](../mockups/team-page.html)
   - バックエンド連携: Team API, TeamGoal API
   - 優先度: 高

5. **デイリー運勢ページ**
   - [モックアップ](../mockups/daily-fortune.html)
   - バックエンド連携: DailyFortune API
   - 優先度: 高

6. **チームページ - 相性表示**
   - [モックアップ](../mockups/team-page.html)
   - バックエンド連携: Compatibility API
   - 優先度: 中

7. **統合AIチャットページ**
   - [モックアップ](../mockups/integrated-chat.html)
   - バックエンド連携: ChatHistory API
   - 優先度: 中

8. **経営者ダッシュボード**
   - バックエンド連携: Alert API, UsageStatistics API
   - 優先度: 中

9. **サブスクリプション管理ページ**
   - バックエンド連携: Subscription API, Invoice API
   - 優先度: 低

10. **SuperAdmin管理サイト**
    - バックエンド連携: 各種管理API
    - 優先度: 最低

## 4. バックエンド実装上の重要な依存関係

実装を進める上で特に注意すべき依存関係を以下に示します：

1. **DailyFortune生成におけるビジネスロジック依存関係**
   - DailyFortuneの生成には、**SajuProfile**、**DayPillar**、**UserGoal**、**TeamGoal**のデータが必要
   - 運勢生成は単なるデータモデル参照だけでなく、複数データソースを組み合わせたビジネスロジックに依存
   - したがって、UserGoalとTeamGoalの実装が先に必要

2. **ChatHistoryにおけるコンテキスト依存関係**
   - AIチャットの実装には、相談モードに応じたコンテキストデータの構築が必要
   - 個人運勢相談: DailyFortune, SajuProfile, UserGoal
   - チームメンバー相談: SajuProfile, Compatibility
   - チーム目標相談: TeamGoal, Team

3. **バッチジョブ間の依存関係**
   - DayPillar生成バッチ処理は、DailyFortune更新バッチ処理の前提条件
   - バッチ処理の実行順序: DayPillar生成 → DailyFortune更新

## 5. 並行開発可能な領域

実装効率を高めるため、以下のタスクは並行して開発可能です：

1. **SajuProfileとDayPillarの同時開発**
   - どちらもSajuEngineに依存しますが、互いに依存関係はない

2. **UserGoalとTeamGoalの同時開発**
   - 両者は独立したエンティティであり、同時に実装可能

3. **フロントエンドの基本コンポーネント開発**
   - バックエンドAPIの実装と並行して、UIコンポーネントの基本骨格を開発可能

4. **共通ユーティリティと基盤コード**
   - エラーハンドリング、認証処理、ログ機能などは他の開発と並行して実装可能

## 6. 優先度の最も高いタスク

1. **SajuEngine連携サービス**
   - 四柱推命計算は多くの機能の前提条件
   - 日柱計算、プロフィール作成、相性判定など多くの機能に影響

2. **DayPillar生成バッチ処理**
   - 日次の運勢生成の前提条件
   - システムの自動化部分であり、早期に安定稼働させる必要がある

3. **TeamGoal/UserGoal API**
   - 運勢生成に必要なデータを提供
   - ユーザーの主要な操作対象となるデータ

4. **DailyFortune生成ロジック**
   - システムの中核機能であり、他の機能との連携が多い
   - Claude AIとの連携が必要な部分

## 7. 改訂された実装フェーズの要約

上記の分析に基づく、依存関係を考慮した実装フェーズの要約：

1. SajuProfile API + DayPillar API → SajuProfile UI
2. TeamGoal API + UserGoal API → Team UI + Goal UI
3. DailyFortune API + Compatibility API → Fortune UI + Team相性表示
4. ChatHistory API → AI Chat UI
5. Subscription + Invoice → 管理機能UI
6. 監視・ログ機能 → 管理者UI

## 8. 結論

データモデルの参照関係だけでなく、ビジネスロジック上の依存関係を考慮した実装順序が重要です。特に、DailyFortuneの生成にはUserGoalとTeamGoalのデータが必要であることを考慮し、実装順序を決める必要があります。また、バッチ処理の依存関係や並行開発可能な領域を把握することで、効率的な開発計画を立てることが可能です。


　# エンティティ関係分析と実装タスク分解プロンプト

## 指示

あなたはシステム設計と実装順序の専門家として、データモデルとビジネスロジックを分析し、最適な実装順序とタスク分解を行ってください。以下のステップに従って分析と計画を行い、具体的かつ実行可能なタスクリストを作成してください。

## 分析ステップ

### 1. データモデル関係の分析
- 提供されたエンティティ（データモデル）の定義を読み解いてください
- 各エンティティ間の参照関係（外部キー関係）を特定してください
- エンティティ依存グラフを作成し、依存方向を明確な矢印で示してください

### 2. ビジネスロジック依存関係の分析
- 各機能の詳細な処理内容とデータフローを把握してください
- **重要**: モデル間の外部キー参照だけでなく、ビジネスロジック上の依存関係も特定してください
  - 例: 運勢生成には、ユーザープロフィール、日柱情報、ユーザー目標、チーム目標のデータが必要
- 機能依存グラフを作成し、データが実際にどのように利用されるかを示してください

### 3. 外部サービス連携の分析
- 外部APIやサービスとの連携ポイントを特定してください
- データの流れとトランスフォーメーションを記述してください
- 依存関係グラフに外部サービスを含めてください

### 4. フロントエンド要件の分析
- UIコンポーネントとバックエンドAPIの関係を特定してください
- 各画面で必要なデータと操作を特定し、対応するAPIエンドポイントを計画してください
- フロントエンド専用の依存関係グラフを作成してください

## 統合依存グラフの作成

上記の分析を統合し、総合的な依存関係グラフを作成してください。この統合グラフには、以下の情報を明確に示してください：

1. **データモデル依存関係**: 通常の矢印で表示（例: `A → B` はAがBを参照）
2. **ビジネスロジック依存関係**: 点線の矢印で表示（例: `A ---> B` はAの処理にBのデータが必要）
3. **外部サービス依存関係**: 波線の矢印で表示（例: `A ~~~> Service` はAが外部サービスに依存）
4. **フロントエンド依存関係**: 二重線矢印で表示（例: `Component ==> API` はコンポーネントがAPIを呼び出す）

## 実装タスクのブレークダウン

統合依存グラフに基づいて、以下の実装タスクリストを作成してください：

1. **フェーズ分け**: 依存関係の順序に従って明確なフェーズに分割
2. **エンティティごとのタスク**: 各エンティティについて必要な実装タスク
   - モデル実装
   - サービス層（ビジネスロジック）
   - コントローラー（APIエンドポイント）
   - ルーティング設定
   - ユニットテスト
3. **外部サービス連携タスク**: 外部サービスとの連携に必要なタスク
4. **バッチ処理タスク**: 定期実行や非同期処理に関するタスク
5. **フロントエンドタスク**: UI実装に関するタスク
   - コンポーネント実装
   - ページ実装
   - API連携サービス実装

## 特別な考慮事項

1. **循環依存関係の識別と対処法の提案**
   - 循環依存を特定したら、これを解消する方法を提案してください
   - 例: 中間テーブルの導入、インターフェース分離など

2. **バッチ処理と自動化の分析**
   - システムの自動化ポイントを特定してください
   - バッチ処理の実行順序と依存関係を明確にしてください

3. **並行開発可能な領域の特定**
   - 依存関係に基づいて並行開発が可能なタスクグループを特定してください
   - フロントエンドとバックエンドの並行開発戦略を提案してください

4. **リスク評価**
   - 実装順序の中でリスクが高い部分を特定してください
   - 複雑な依存関係を持つコンポーネントには特に注意してください

## 出力形式

以下の形式で出力してください：

1. **統合依存関係グラフ**: 図を用いて（テキストベースの図も可）、上記で説明した表記法で依存関係を明示
2. **実装フェーズ一覧**: 依存関係に基づいた論理的なフェーズ分け
3. **詳細タスクリスト**: 各フェーズ内のタスクを詳細に列挙
4. **並行開発可能なタスクグループ**: 同時に進められるタスクのグループ化
5. **リスク評価とミティゲーション戦略**: 実装時に注意すべきポイントと対策

## 具体的なプロジェクト情報

以下のプロジェクト情報に基づいて分析を行ってください：

1. **データモデル**:
   - [提供されたデータモデル情報・図をここに挿入]

2. **ビジネスロジック要件**:
   - [機能要件や処理フローの説明をここに挿入]

3. **外部サービス連携**:
   - [外部APIやサービスとの連携情報をここに挿入]

4. **技術スタック**:
   - [使用する技術やライブラリ情報をここに挿入]

## 重要な注意点

- 単なるデータモデルの参照関係だけでなく、**ビジネスロジックの流れ**を重視してください
- ある機能が他の機能のデータに依存する場合、その依存関係を明確に示してください
- 実装順序は「できるだけ早く動くプロトタイプを作る」という観点ではなく「依存関係に基づく論理的な実装順序」を優先してください
- 分析の過程で不明点や追加情報が必要な場合は、質問してください
- タスク分解は、1人の開発者が実装する場合でも追跡可能な粒度にしてください（目安: 1タスク = 0.5〜2日）


  1. 依存関係を明示する - 「タスクBを始める前にタスクAが完了してい
  る必要がある」のように明確に依存関係を述べる
  2. 優先度をランク付けする -
  「最優先」「高」「中」「低」などで優先順位を示す
  3. フェーズや段階を区切る -
  「フェーズ1はこれらのタスク」「完了条件はこれ」と明確に区分する
  4. 具体的な制約条件を挙げる - 「データが存在しないと次のステップ
  に進めない」などの制約を明示する
  5. MVPアプローチを指定する - 「まず基本機能を実装し、後から拡張機
  能を追加する」という方針を示す
  6. 完了基準を定義する -
  各タスクの「完了」を判断する基準を明確にする
  7. 開発フローを説明する -
  「モデル定義→API実装→UI開発」のような一般的な流れを示す

  これらの要素を組み合わせ、明確かつ構造化された指示を提供すると効
  果的です。


  # エンドポイントとUI連携の実装タスク分解プロンプト 4.0

## ミッション

あなたはシステム設計と実装順序の専門家として、既存の設計資料からAPIエンドポイントを抽出し、データ依存関係に基づいた最適な実装順序を分析・決定します。バックエンドとフロントエンドの連携を考慮し、効率的な並行開発を可能にする実装計画を提案します。この作業は2段階で行い、まず全体的な実装順序と依存関係を明確にした `implementation_order.md` を作成し、次に詳細なタスクブレークダウンを含む `implementation_tasks.md` を作成します。さらに、プロジェクト管理のために `CURRENT_STATUS.md` の更新も行います。

## 分析の入力情報

### 1. 既存の設計資料の活用
- **API仕様書**: 
  - `docs/api/[カテゴリ名].md` - 機能カテゴリ別のAPI仕様
- **データモデル分析**: 
  - `docs/data_models/integrated_model.md` - 統合データモデル
  - `docs/data_models/erd.md` - エンティティ関係図
- **モックアップ成果物**: 
  - `mockups/[ページ名].html` - モックアップファイル
  - `docs/ui/[ページ名].md` - UI設計と状態管理ガイド
- **実装ガイド**:
  - `docs/implementation/[ページ名].md` - ページごとの実装ガイド

### 2. 共有定義ファイル
- `shared/index.ts` - 型定義・API定数の確認

### 3. プロジェクト状況
- `docs/CURRENT_STATUS.md` - プロジェクトの現在の状況

## 分析ステップ

### 1. 全APIエンドポイントの抽出
- API仕様書（`docs/api/*.md`）から**すべてのエンドポイント**を抽出
- 各エンドポイントの目的、入出力、必要なデータモデルを明確化
- エンドポイントをデータ操作タイプ（作成/取得/更新/削除）で分類

### 2. データレイヤーによるグループ化
- データモデルの依存関係に基づいて、エンドポイントを**データレイヤー**でグループ化：
  - **レイヤー0: 基盤データ層** - 認証、基本エンティティ管理API
  - **レイヤー1: 主要エンティティ層** - プロジェクトの主要データAPI
  - **レイヤー2: 派生データ層** - 主要データを基にした派生機能API
  - **レイヤー3: 高次機能層** - 高度な分析や連携機能API

### 3. データ依存関係の分析
- データモデル間の依存関係を分析し、**前提条件となるデータ**を特定
- モデルAを作成するにはモデルBが必要、などの関係を明確化
- データの生成から消費への自然な流れを図式化

### 4. UIコンポーネントとエンドポイントの対応分析
- モックアップからUIコンポーネントを抽出
- 各UIコンポーネントがどのエンドポイントを利用するかマッピング
- コンポーネントの依存関係を分析

### 5. 外部サービス連携の分析
- 外部APIやサービスに依存するエンドポイントを特定
- データの流れとトランスフォーメーションを記述
- 依存関係グラフに外部サービスを含める

## 実装順序計画の作成 (implementation_order.md)

データ依存関係とエンドポイント/UIコンポーネントの対応に基づき、以下を含む実装順序計画を作成してください:

1. **統合依存関係グラフ**: 
   - エンドポイント間の依存関係を図式化
   - データモデル依存関係: 通常の矢印 `A → B` (AがBのデータに依存)
   - API呼び出し依存関係: 点線の矢印 `A ---> B` (AのAPIがBのAPIを呼び出す)
   - UIコンポーネント依存関係: 二重線矢印 `Component ==> API` (UIがAPIを呼び出す)

2. **データレイヤー別エンドポイントグループ**:
   - データの依存関係に基づいたレイヤー分け
   - 各レイヤー内のエンドポイントリスト
   - レイヤー間の依存関係の説明

3. **実装フェーズ計画**:
   - フェーズ0: HTML/CSSモックアップのコンポーネント構造への変換
   - フェーズ1〜4: データレイヤーに対応するバックエンド・フロントエンド実装
   - 各フェーズの目標と完了条件の定義

4. **優先順位策定**:
   - データ生成から消費への自然な流れを重視
   - 各エンドポイントとUIコンポーネントの優先度（最高/高/中/低）
   - ボトルネックになる可能性のある実装ポイントの特定

5. **並行開発戦略**:
   - バックエンドとフロントエンドの並行開発計画
   - モックデータを活用するUI開発とAPI実装の連携タイミング
   - 依存関係のない領域の特定

## 詳細タスク計画の作成 (implementation_tasks.md)

実装順序計画に基づいて、バックエンドとフロントエンドの並行開発を考慮した詳細なタスク計画を作成してください:

1. **フェーズ0: モックアップのコンポーネント構造への変換**:
   - HTML/CSSモックアップから基本的なコンポーネント構造への変換
   - 共通UIコンポーネントの抽出と実装
   - 静的な表示とスタイリングの実装
   - モックデータの準備

2. **レイヤー別タスクリスト**:
   - 各レイヤーのバックエンド実装タスク
     - エンドポイントごとの垂直実装単位（サービス→コントローラー→ルート→テスト）
   - 対応するフロントエンド実装タスク
     - モックデータによる機能実装
     - 実APIと連携する実装への置き換え
   - タスクの依存関係と実装順序

3. **バックエンド実装詳細**:
   - **サービス層**:
     - 必要なデータモデルの確認
     - ビジネスロジックの実装
     - 依存サービスとの連携
   - **コントローラー**:
     - リクエスト検証
     - サービス呼び出し
     - レスポンス整形
   - **ルート設定**:
     - エンドポイントの登録
     - ミドルウェア適用
     - API文書注釈追加
   - **テスト実装**:
     - 単体テスト
     - 統合テスト
     - エラーケーステスト

4. **フロントエンド実装詳細**:
   - **コンポーネント構造変換**:
     - HTML/CSSからReactコンポーネントへの変換
     - コンポーネント階層の設計
     - 共通UIライブラリの構築
   - **状態管理**:
     - モックデータの設定
     - コンポーネント状態の定義
     - データフローの設計
   - **API連携**:
     - APIサービスクラスの実装
     - モックデータから実APIへの切り替え
     - エラー処理とローディング状態の管理

5. **タスクの工数見積もり**:
   - 各実装ステップの工数見積もり（0.5〜2日の粒度）
   - タスクの複雑さに基づく調整
   - 前提条件と依存関係の明確化

## CURRENT_STATUS.md の更新計画

実装タスク計画に基づいて、`CURRENT_STATUS.md`の更新内容を作成してください:

1. **実装状況セクション**:
   - バックエンド: レイヤー別のエンドポイント実装状況
   - フロントエンド: モックアップ変換とAPI連携の状況
   - 実装完了率のレイヤー別集計
   - 全体の進捗状況サマリー

2. **次の実装優先順位**:
   - データ依存関係を考慮した次に実装すべき項目
   - 優先度の高いエンドポイントとUIコンポーネント
   - 並行して進めるべきバックエンドとフロントエンドのタスク

3. **ディレクトリ構造の更新**:
   - 新規作成予定のファイル
   - 更新予定のファイル
   - テスト関連ファイル

## 実装アプローチ

### バックエンド: エンドポイント中心の垂直スライス実装

各APIエンドポイントに対して、以下の垂直的な実装単位を作成します:

1. **要件確認**:
   - API仕様書の詳細レビュー
   - 必要なデータモデルの確認
   - 前提条件となるエンドポイントの確認

2. **サービス層の実装**:
   - ビジネスロジックの実装
   - データモデル操作
   - エラー処理ロジック

3. **コントローラーの実装**:
   - リクエストのバリデーション
   - サービス呼び出し
   - レスポンス整形とエラーハンドリング

4. **ルート設定の実装**:
   - エンドポイントの登録
   - 認証/認可ミドルウェアの適用
   - API文書注釈追加

5. **テストの実装**:
   - 単体テスト
   - 統合テスト
   - エラーケーステスト

### フロントエンド: モックアップからの段階的実装

フロントエンド実装は以下の段階で進めます:

1. **基本構造変換**:
   - HTMLモックアップをコンポーネント構造に変換
   - 視覚的要素とスタイリングの実装
   - 共通コンポーネントの抽出

2. **モックデータを使用した機能実装**:
   - 静的なコンポーネントにインタラクティブな機能を追加
   - モックデータを使用して動作を実装
   - コンポーネント間の状態管理を実装

3. **APIとの連携**:
   - 実際のAPIエンドポイントとの接続
   - モックデータから実データへの切り替え
   - エラー処理とローディング状態の実装

4. **統合テストと最適化**:
   - エンドツーエンドテスト
   - パフォーマンス最適化
   - エラー処理の完成

### データ依存関係に基づく連携と並行開発

1. **バックエンド開発とフロントエンド開発の並行進行**:
   - フェーズ0でUIコンポーネント基本構造を先行実装
   - 各データレイヤーのAPIとUIを並行して開発
   - APIが完成していないUIはモックデータで先行開発

2. **段階的な実装と統合**:
   - 基盤データ層を最初に実装し、上位レイヤーへ進む
   - 各レイヤー内でエンドポイントごとの開発と対応するUI実装
   - レイヤー完了ごとの統合テストと検証

## 出力書式

### implementation_order.md の形式
```markdown
# 実装順序計画

## 依存関係の全体図
[依存関係グラフの図またはテキスト表現]

## データレイヤー別グループ

### レイヤー0: 基盤データ層
- **APIグループA**
  - `POST /api/v1/endpoint1` - 説明
  - `GET /api/v1/endpoint2` - 説明
  
- **APIグループB**
  - `POST /api/v1/endpoint3` - 説明
  - `GET /api/v1/endpoint4` - 説明

[以下同様に他のレイヤーについて記述]

## 実装フェーズ計画

### フェーズ0: モックアップ基本変換
- **目標**: HTMLモックアップをUI基本コンポーネント構造に変換
- **完了条件**: 視覚的に同等の静的Reactコンポーネントが完成
- **主要タスク**:
  - 共通コンポーネントの抽出と実装
  - ページコンポーネントの基本構造実装
  - スタイリングシステムの構築

### フェーズ1: 基盤データレイヤー実装
- **目標**: [フェーズの目標]
- **完了条件**: [完了条件]
- **バックエンドタスク**: 
  - [APIエンドポイント実装タスク]
- **フロントエンドタスク**:
  - [UI実装タスク]

[以下同様に他のフェーズについて記述]

## 優先順位と並行開発戦略
...
```

### implementation_tasks.md の形式
```markdown
# 実装タスク詳細計画

このドキュメントでは、バックエンドAPIとフロントエンドUIの実装タスクを、データの依存関係と自然なユーザーフローに基づいて細分化し、論理的な実装順序で記述します。

## フェーズ0: モックアップ基本変換

### 共通UIコンポーネント実装 (3日)
- [ ] 共通ボタンコンポーネント
  - [ ] `client/src/components/common/Button.tsx` の作成
  - [ ] バリエーション（プライマリ/セカンダリ/テキスト）の実装
  - [ ] 状態（通常/ホバー/アクティブ/無効）の実装

- [ ] 共通フォーム要素
  - [ ] `client/src/components/common/Input.tsx` の作成
  - [ ] `client/src/components/common/Select.tsx` の作成
  - [ ] バリデーション状態の視覚的表現

[他の共通コンポーネント...]

### ページ基本構造実装 (5日)
- [ ] `client/src/pages/Page1/index.tsx` の作成
  - [ ] 対応するモックアップの基本レイアウト構造実装
  - [ ] 共通コンポーネントの統合
  - [ ] 静的コンテンツの配置

[他のページコンポーネント...]

## フェーズ1: 基盤データレイヤー実装

### バックエンド: APIエンドポイント1

#### 1. POST /api/v1/endpoint1 (工数: 2日)
- [ ] サービス層の実装 (0.5日)
  - [ ] `server/src/services/service1.ts` の実装
  - [ ] ビジネスロジックの実装
  - [ ] エラーハンドリング実装
  
- [ ] コントローラーの実装 (0.5日)
  - [ ] `server/src/controllers/controller1.ts` の実装
  - [ ] リクエストのバリデーション
  - [ ] レスポンス整形

[他のバックエンドタスク...]

### フロントエンド: 対応するUI実装

#### 1. コンポーネント機能実装 (工数: 1.5日)
- [ ] `client/src/components/feature1/Component1.tsx` の作成
  - [ ] モックデータでの動作実装
  - [ ] ユーザーインタラクションの実装
  - [ ] 状態管理の実装

[他のフロントエンドタスク...]

### API連携実装 (工数: 0.5日)
- [ ] `client/src/services/api1.service.ts` の作成
  - [ ] APIクライアント実装
  - [ ] エンドポイント呼び出し関数の実装
  - [ ] エラーハンドリングの実装

#### モックデータからAPIへの移行 (工数: 0.5日)
- [ ] モックデータからAPIデータへの切り替え
  - [ ] APIサービスの統合
  - [ ] ローディング状態の管理
  - [ ] エラー表示の実装

[以下同様に他のレイヤーのタスクを記述]
```

### CURRENT_STATUS.md の更新内容
```markdown
[既存の内容を尊重しつつ、以下を追加・更新]

## 実装状況

### バックエンド実装状況
#### レイヤー0: 基盤データ層 (完了率: 30%)
- [x] エンドポイント1 - 説明 
- [x] エンドポイント2 - 説明
- [ ] エンドポイント3 - 説明 (進行中)
- [ ] [他の未実装エンドポイント...]

[以下同様に他のレイヤーについて記述]

### フロントエンド実装状況
#### モックアップ変換 (完了率: 60%)
- [x] 共通コンポーネント
- [x] ページ1の基本構造
- [ ] ページ2の基本構造 (進行中)
- [ ] [他の未実装コンポーネント...]

#### API連携 (完了率: 20%)
- [x] 機能1のAPI連携
- [ ] 機能2のAPI連携 (進行中)
- [ ] [他の未実装API連携...]

## 次の実装優先順位

データ依存関係とユーザーフローに基づき、以下の順序で実装を進めることを推奨します：

### バックエンド優先順位
1. **エンドポイント3** (最優先)
   - 説明: [説明文]
   - 必要ファイル: [ファイルリスト]

### フロントエンド優先順位
1. **ページ2の基本構造完成** (最優先)
   - 説明: [説明文]
   - 必要ファイル: [ファイルリスト]
```

## 重要な注意点

- バックエンドとフロントエンドの並行開発を考慮した実装計画を作成してください
- モックアップからUIコンポーネントへの変換をフェーズ0として先行実装し、その後のAPI実装と連携させてください
- データ依存関係を重視し、「データ生成→データ消費」という自然な流れに沿った実装順序を優先してください
- エンドポイント単位での垂直的な実装と、UIコンポーネント単位での段階的な実装を効果的に組み合わせてください
- プロジェクト固有の具体的な名称を避け、汎用的な表現を使用してください
- 大規模プロジェクトにも少人数チームにも適用できる柔軟な計画を作成してください